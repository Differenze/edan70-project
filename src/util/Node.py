import pydot
import regex as re
# str 			ID 				what this node is called
# [Edge]		out_edges 		edges leaving this node
# [Edge]		in_edges 		edges entering this node
# str 			type_string		what type is this node, e.g. ADD/SUB/C

# default labels are used when creating new nodes
DEFAULT_LABELS = {
	'opadd' 	: '{{<left> left | <right> right} | <out> add}',
	'opsub' 	: '{{<left> left | <right> right} | <out> sub}',
	'c'			: 'USE Graph.create_constant for sane defaults',
	'ff'		: 'ff',
	'out'		: 'out (TODO solve dis)',
	'validout'	: 'validout',	#TODO make these work right
	'validin'	: 'validin',
	'validff'	: 'validff',
	'pidff'		: 'pidff',
	'pidout'	: 'pidout',
	'pidin'		: 'pidin',
	'in'		: 'in',
}

class Node:
	MAX_ID = 0 # highest ID encountered


	# constructor
	# type_string 		the node type, e.g. "opadd", "bitconcat"
	# ID				autogenerated from MAX_ID when None
	# label				autogenerated from DEFAULT_LABELS when None
	# info				contains further information as a dictionary
	def __init__(self,
				type_string,
				ID,
				**info):
		self.visited = False 
		self.out_edges = []
		self.in_edges = []
		self.ID = ID
		self.info=info
		if not ID:
			Node.MAX_ID += 1
			self.ID = type_string+'_'+str(Node.MAX_ID)
		self.type_string = type_string
		self.label = info.get('label', None)
		# if not self.label:
		# 	#TODO we don't need default labels if we parse well I believe
		# 	if type_string not in DEFAULT_LABELS:
		# 		print("No default label found for this type: ", type_string) 
		# 		# look at type_string and create a default in DEFAULT_LABELS
		# 		exit(-1)
		# 	self.label = DEFAULT_LABELS[type_string]
		# #TODO remove obj_dict and replace with info
		# self.obj_dict = {}
		# self.obj_dict['attributes'] = {}
		# self.obj_dict['attributes']['label'] = self.label


	# creates a node from a pydot.Node object
	@staticmethod
	def new_node_from_pydot(pydot_node):
		ID = pydot_node.get_name()
		type_string = pydot_node.get_name().split('_')[0:1][0]
		label = pydot_node.get_label()
		node = Node(type_string, ID, label)
		node.obj_dict = pydot_node.obj_dict
		print(node.obj_dict)
		if ID in ['validout', 'validin', 'pidout', 'pidin']:
			idnum = -1
		else:
			idnum = int(ID.split('_')[1:][0])
		if idnum > Node.MAX_ID:
			Node.MAX_ID = idnum
		return node

	# creates a new node from the string given in a dot file
	@staticmethod
	def new_from_string(dot_string):
		dot_string = dot_string.rstrip('\n;')
		print(dot_string)

		parse = {
			'label'			: 'label="([^\]"]*)"',
			'debug'			: 'debug="([^\]"]*)"',
			'shape'			: 'shape=([^\s]*)\s',
			'style'			: 'style="([^\]"]*)"',
			'color'			: 'color="([^\]"]*)"',
			'length'		: '\[l=([^\]]*)\]',
			'delay'			: '\[d=([^\]]*)\]',
			'width'			: '\[w=([^\]]*)\]',
			'operator_delay': '\[od=([^\]]*)\]',
			'type_string'	: '^(.*?)[_|\[]',
			'ID'			: '^(.*?_?\d*)[\[|\s]',
		}
		info = {}

		for tag, regex in parse.iteritems():
			match = re.search(regex, dot_string)
			# print(match)
			if(match):
				info[tag] = match.group(1)
				# print(tag+': '+info[tag])
		print(info)
		# node = Node(info['type_str'], info['ID'], info['label'], info)
		node = Node(**info)
		return node

	def insertFF(self, graph):
		for index, edge in enumerate(self.out_edges):
			FF = graph.create_node("ff")
			old_head = edge.head
			edge.head = FF
			new_edge = graph.create_edge(FF,old_head,edge.width, None, edge.head_pos, None)	
			edge.head_pos = None		


	# add edge as an output edge from this node
	def add_succ(self, edge):
		self.out_edges.append(edge)
		#print("add_succ:", str(self), str(edge), len(self.out_edges))


	# add edge as an input edge to this node
	def add_pred(self, edge):
		self.in_edges.append(edge)
		#print("add_pred:", str(self), str(edge), len(self.in_edges))


	# string format for printouts
	def __str__(self):
		return 'Node: %(ID)s %(type_s)s %(label)s' % ({'ID':self.ID, 'type_s':self.type_string, 'label':self.label})


	def input_edges(self):
		return self.in_edges


	def output_edges(self):
		return self.out_edges

	# returns the left input if it exists
	def left_edge(self):
		for edge in self.in_edges:
			if edge.head_pos == 'left':
				return edge


	# returns the right input if it exists
	def right_edge(self):
		for edge in self.in_edges:
			if edge.head_pos == 'right':
				return edge


	# returns true if this node is a constant
	def is_constant(self):
		return self.type_string == 'c'


	# returns value if this node is a constant
	def constant_value(self):
		if self.is_constant():
			return int(self.label[1:-1])
		else:
			print('ERR calling constant_value on a node which isn\'t constant')


	# returns list of nodes to which this node is an input
	def output_nodes(self):
		ret = []
		for edge in self.out_edges:
			ret.append(edge.head)
		return ret


	# returns a string representation using the dot format
	# modified from pydot source because attributes need
	# to be ordered for pacopt
	def dot_string(self):
		node = self.ID
		# attributes follow this order:
		attr_list = ['label', 'shape', 'color', 'style', 'debug']
		node_attr = []

		for attr in attr_list:
			if attr in self.info:
				node_attr.append('{}="{}"'.format(attr, self.info[attr]))

		# for attr in attr_list:
		# 	if attr in self.obj_dict['attributes']:
		# 		value = self.obj_dict['attributes'][attr]
		# 		if value == '':
		# 			value = '""'
		# 		if value is not None:
		# 			node_attr.append('%s=%s' % (attr, pydot.quote_if_necessary(value)))


		node_attr = ' '.join(node_attr)
		if node_attr:
			node += '[' + node_attr + ']'

		brackets = [
			['length','l'],
			['delay', 'd'],
			['width', 'w'],
			['operator_delay', 'od']
		]

		for name, tag in brackets:
			if name in self.info:
				node += '[{}={}]'.format(tag, self.info[name])

		return node + ';'


	# update label
	def set_label(self, value):
		self.label=value
		self.set_attrib('label', value)

	# update any attribute
	def set_attrib(self, attrib, value):
		self.obj_dict['attributes'][attrib] = value
